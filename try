warn("v2 - Targeting CoinVisual instead of Coin_Server")

-- ============================================
-- COIN AUTOFARM SYSTEM v2
-- Version: Targets CoinVisual for precise movement
-- ============================================

-- ========== CONFIGURATION ==========
local config = {
    -- Movement settings
    WalkSpeed = 22, -- Normal human walking speed
    JumpPower = 50,
    SmoothTurn = true,
    TurnSmoothness = 0.6,
    
    -- Collection settings
    CoinRadius = 50, -- How close to get to CoinVisual (smaller radius)
    WaitAfterCollect = 0.01,
    MaxSearchDistance = 500,
    
    -- Optimization settings
    CacheCoins = true,
    CacheTime = 1,
    PathRefreshRate = 0.2,
    
    -- Safety settings
    MaxAttemptsPerCoin = 3,
    StuckDetection = true,
    StuckTimeout = 5,
    
    -- New: CoinVisual targeting
    TargetCoinVisual = true, -- Set to false to target Coin_Server instead
    VisualPartName = "CoinVisual"
}

-- ========== INITIALIZATION ==========
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

Humanoid.AutoRotate = true

-- ========== CORE FUNCTIONS ==========

-- Cache system for performance
local coinCache = {
    activeCoins = {},
    lastUpdate = 0,
    container = nil
}

local function findCoinContainer()
    if coinCache.container and coinCache.container.Parent then
        return coinCache.container
    end
    
    -- Search in Workspace.IceCastle
    local iceCastle = Workspace:FindFirstChild("IceCastle")
    if iceCastle and iceCastle:FindFirstChild("CoinContainer") then
        coinCache.container = iceCastle.CoinContainer
        return coinCache.container
    end
    
    -- Fallback: search all models
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj:IsA("Model") and obj:FindFirstChild("CoinContainer") then
            coinCache.container = obj.CoinContainer
            return coinCache.container
        end
    end
    return nil
end

local function getCoinVisualPosition(coinServer)
    -- Get the actual CoinVisual part for precise targeting
    if not coinServer or not coinServer.Parent then return nil end
    
    if config.TargetCoinVisual then
        local coinVisual = coinServer:FindFirstChild(config.VisualPartName)
        if coinVisual and coinVisual:IsA("BasePart") then
            return coinVisual.Position
        end
    end
    
    -- Fallback to Coin_Server position
    return coinServer.Position
end

local function updateCoinCache()
    local currentTime = tick()
    
    -- Only update cache periodically
    if currentTime - coinCache.lastUpdate < config.CacheTime then
        return coinCache.activeCoins
    end
    
    local container = findCoinContainer()
    if not container then
        coinCache.activeCoins = {}
        return coinCache.activeCoins
    end
    
    local newActiveCoins = {}
    
    for _, coinServer in pairs(container:GetChildren()) do
        if coinServer.Name == "Coin_Server" and coinServer:IsA("BasePart") then
            -- Check if coin is collectible (Transparency = 1)
            if coinServer.Transparency == 1 and coinServer.Parent then
                -- Get the actual target position (CoinVisual if exists)
                local targetPosition = getCoinVisualPosition(coinServer)
                if not targetPosition then continue end
                
                -- Store both parts for reference
                table.insert(newActiveCoins, {
                    ServerPart = coinServer,
                    VisualPart = coinServer:FindFirstChild(config.VisualPartName),
                    Position = targetPosition, -- This is CoinVisual position!
                    LastSeen = currentTime,
                    Attempts = 0,
                    IsCollecting = false,
                    Collectible = true
                })
            end
        end
    end
    
    coinCache.activeCoins = newActiveCoins
    coinCache.lastUpdate = currentTime
    
    -- Debug output
    if #newActiveCoins > 0 then
        print(string.format("[Cache] Found %d active coins", #newActiveCoins))
    end
    
    return newActiveCoins
end

local function isBagFull()
    local success, result = pcall(function()
        local gui = LocalPlayer.PlayerGui:FindFirstChild("MainGUI")
        if not gui then return false end
        
        local gameGui = gui:FindFirstChild("Game")
        if not gameGui then return false end
        
        local coinBags = gameGui:FindFirstChild("CoinBags")
        if not coinBags then return false end
        
        local container = coinBags:FindFirstChild("Container")
        if not container then return false end
        
        local snowToken = container:FindFirstChild("SnowToken")
        if not snowToken then return false end
        
        -- Check coin count
        local currencyFrame = snowToken:FindFirstChild("CurrencyFrame")
        if currencyFrame then
            local icon = currencyFrame:FindFirstChild("Icon")
            if icon then
                local coinsText = icon:FindFirstChild("Coins")
                if coinsText and coinsText:IsA("TextLabel") then
                    local coins = tonumber(coinsText.Text)
                    if coins and coins >= 50 then
                        return true
                    end
                end
            end
        end
        
        -- Check full indicator
        local fullIndicator = snowToken:FindFirstChild("Full")
        if fullIndicator and fullIndicator.Visible then
            return true
        end
        
        return false
    end)
    
    return success and result or false
end

local function getClosestCoin()
    local activeCoins = updateCoinCache()
    if #activeCoins == 0 then return nil end
    
    local closestCoin = nil
    local closestDistance = math.huge
    local playerPos = HumanoidRootPart.Position
    
    for _, coinData in pairs(activeCoins) do
        if coinData.ServerPart and coinData.ServerPart.Parent and coinData.Collectible then
            local distance = (coinData.Position - playerPos).Magnitude
            
            -- Skip if too far or already being collected
            if distance < closestDistance and distance < config.MaxSearchDistance 
               and not coinData.IsCollecting then
                closestDistance = distance
                closestCoin = coinData
            end
        end
    end
    
    return closestCoin, closestDistance
end

-- ========== PATHFINDING SYSTEM ==========
local currentPath = nil
local pathGoal = nil
local lastPathUpdate = 0
local stuckCheck = {
    lastPosition = Vector3.new(),
    stuckTime = 0
}

local function createSmoothPath(destination)
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        WaypointSpacing = 3, -- Reduced for more precision
        Costs = {
            Water = 20,
            Lava = math.huge
        }
    })
    
    local startPos = HumanoidRootPart.Position
    path:ComputeAsync(startPos, destination)
    
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        
        -- Filter waypoints but keep more for CoinVisual precision
        local filteredWaypoints = {}
        for i, waypoint in ipairs(waypoints) do
            -- Keep more waypoints near the end for precision
            local isNearEnd = i > #waypoints - 3
            if i == 1 or i == #waypoints or isNearEnd or i % 2 == 0 then
                table.insert(filteredWaypoints, waypoint)
            end
        end
        
        return filteredWaypoints
    else
        print("[Pathfinding] Failed to compute path:", path.Status)
        return nil
    end
end

local function moveToWaypoint(waypoint)
    Humanoid:MoveTo(waypoint.Position)
    
    -- Add human-like delay
    if waypoint.Action == Enum.PathWaypointAction.Jump then
        Humanoid.Jump = true
        task.wait(0.2)
    end
    
    -- Wait until reached or timeout
    local startTime = tick()
    local waypointTimeout = 3
    
    while (HumanoidRootPart.Position - waypoint.Position).Magnitude > 4 do
        local elapsed = tick() - startTime
        
        -- Timeout check
        if elapsed > waypointTimeout then
            print("[Movement] Waypoint timeout")
            return false
        end
        
        -- Stuck detection
        if config.StuckDetection then
            local movedDistance = (HumanoidRootPart.Position - stuckCheck.lastPosition).Magnitude
            if movedDistance < 0.5 then
                stuckCheck.stuckTime = stuckCheck.stuckTime + RunService.Heartbeat:Wait()
                if stuckCheck.stuckTime > 1 then
                    -- Jump to get unstuck
                    Humanoid.Jump = true
                    stuckCheck.stuckTime = 0
                    print("[Movement] Jumping to unstuck")
                end
            else
                stuckCheck.lastPosition = HumanoidRootPart.Position
                stuckCheck.stuckTime = 0
            end
        end
        
        RunService.Heartbeat:Wait()
    end
    
    return true
end

local function moveToCoinSmooth(coinPosition, coinData)
    local waypoints = createSmoothPath(coinPosition)
    if not waypoints then return false end
    
    -- Reset stuck detection
    stuckCheck.lastPosition = HumanoidRootPart.Position
    stuckCheck.stuckTime = 0
    
    -- Follow waypoints
    for i, waypoint in ipairs(waypoints) do
        -- Check if coin is still valid
        if not coinData.ServerPart or not coinData.ServerPart.Parent then
            print("[Movement] Coin disappeared during movement")
            return false
        end
        
        -- Check distance to coin (using CoinVisual position)
        local distanceToCoin = (HumanoidRootPart.Position - coinPosition).Magnitude
        if distanceToCoin <= config.CoinRadius then
            print("[Movement] Close enough to collect")
            return true
        end
        
        -- Move to waypoint
        if not moveToWaypoint(waypoint) then
            return false
        end
        
        -- Small pause between waypoints (more human-like)
        if i < #waypoints then
            local pause = 0.03 + math.random() * 0.07
            task.wait(pause)
        end
    end
    
    return true
end

-- ========== MAIN AUTOFARM LOOP ==========
local function autofarmLoop()
    print("[Autofarm v2] Starting CoinVisual targeting...")
    print(string.format("Targeting: %s", config.TargetCoinVisual and "CoinVisual" or "Coin_Server"))
    
    while _G.Autofarm do
        -- Safety checks
        if not Character or not Character.Parent then
            Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            Humanoid = Character:WaitForChild("Humanoid")
            HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        end
        
        -- Check if bag is full
        if isBagFull() then
            print("[Autofarm] Bag is full! Pausing...")
            Humanoid:MoveTo(HumanoidRootPart.Position)
            for i = 1, 10 do
                if not _G.Autofarm then break end
                if not isBagFull() then break end
                task.wait(1)
            end
            continue
        end
        
        -- Find closest coin (targeting CoinVisual position)
        local coinData, distance = getClosestCoin()
        
        if not coinData then
            print("[Autofarm] No active coins found. Waiting...")
            Humanoid:MoveTo(HumanoidRootPart.Position)
            
            -- Look around naturally while waiting
            if math.random() < 0.3 then
                Humanoid.Jump = true
            end
            
            task.wait(1.5)
            continue
        end
        
        -- Attempt tracking
        coinData.Attempts = coinData.Attempts + 1
        if coinData.Attempts > config.MaxAttemptsPerCoin then
            print("[Autofarm] Skipping coin after", coinData.Attempts, "attempts")
            coinData.IsCollecting = false
            coinData.Collectible = false
            task.wait(0.5)
            continue
        end
        
        -- Mark as collecting
        coinData.IsCollecting = true
        
        -- Move to CoinVisual position
        print(string.format("[Autofarm] Moving to coin (%.1f meters)", distance))
        print(string.format("  Position: %s", tostring(coinData.Position)))
        
        local success = moveToCoinSmooth(coinData.Position, coinData)
        
        if success then
            print("[Autofarm] Reached coin area")
            
            -- Very brief pause (makes it look natural)
            task.wait(0.1 + math.random() * 0.2)
            
            -- Mark as collected
            coinData.Attempts = 0
            coinData.Collectible = false
            
            -- Small celebration sometimes
            if math.random() < 0.2 then
                Humanoid.Jump = true
            end
        else
            print("[Autofarm] Failed to reach coin")
        end
        
        coinData.IsCollecting = false
        
        -- Natural delay between attempts
        task.wait(0.2 + math.random() * 0.4)
    end
    
    print("[Autofarm] Stopped")
    Humanoid:MoveTo(HumanoidRootPart.Position)
end

-- ========== CONTROLS ==========
function toggleAutofarm()
    _G.Autofarm = not _G.Autofarm
    
    if _G.Autofarm then
        print("[Autofarm v2] ENABLED - Targeting CoinVisual")
        task.spawn(autofarmLoop)
    else
        print("[Autofarm v2] DISABLED")
    end
end

-- ========== DEBUG FUNCTIONS ==========
local function debugCoinStructure()
    print("\n=== DEBUG: Coin Structure ===")
    local container = findCoinContainer()
    if not container then
        print("CoinContainer not found!")
        return
    end
    
    print("Found CoinContainer with", #container:GetChildren(), "children")
    
    for i, coin in pairs(container:GetChildren()) do
        if coin.Name == "Coin_Server" then
            print(string.format("\nCoin_Server #%d:", i))
            print("  Transparency:", coin.Transparency)
            print("  Position:", tostring(coin.Position))
            
            local visual = coin:FindFirstChild("CoinVisual")
            if visual then
                print("  Has CoinVisual: YES")
                print("  Visual Position:", tostring(visual.Position))
                print("  Visual Transparency:", visual.Transparency)
            else
                print("  Has CoinVisual: NO")
            end
        end
    end
    print("=== END DEBUG ===\n")
end

-- ========== STARTUP ==========
-- Character reconnection
LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    task.wait(0.5)
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    
    Humanoid.WalkSpeed = config.WalkSpeed
    Humanoid.JumpPower = config.JumpPower
end)

-- Auto-start if enabled
if _G.Autofarm then
    task.wait(1)
    task.spawn(autofarmLoop)
end

print("[Autofarm v2] System loaded!")
print("Commands: toggleAutofarm(), debugCoinStructure()")
print("Config: TargetCoinVisual =", config.TargetCoinVisual)
print("Current status: Autofarm =", _G.Autofarm or false)

-- Run debug to verify structure
task.wait(2)
debugCoinStructure()
