-- BYTECODE PATTERN DECODER - Attempts to decode common patterns
local BytecodeDecoder = {}
BytecodeDecoder.__index = BytecodeDecoder

function BytecodeDecoder.new()
    local self = setmetatable({}, BytecodeDecoder)
    
    -- Common Luau instruction patterns (REVERSE-ENGINEERED, may be wrong!)
    self.opcodePatterns = {
        -- Format: {hex_pattern, possible_meaning}
        ["1B4C7561"] = {"Luau signature", "SCRIPT_HEADER"},
        ["00..02..04"] = {"Function header", "FUNC_START"},
        ["2A......"] = {"LOADK - Load constant", "local x = K"},
        ["36......"] = {"GETGLOBAL - Get global", "game"},
        ["3C......"] = {"SETGLOBAL - Set global", "x = value"},
        ["42......"] = {"GETTABLE - Table access", "x.y or x[y]"},
        ["48......"] = {"SETTABLE - Table write", "x.y = z"},
        ["4E......"] = {"NEWTABLE - Create table", "{}"},
        ["54......"] = {"SELF - Method call prep", "x:method()"},
        ["5A......"] = {"ADD - Addition", "a + b"},
        ["60......"] = {"SUB - Subtraction", "a - b"},
        ["66......"] = {"MUL - Multiplication", "a * b"},
        ["6C......"] = {"DIV - Division", "a / b"},
        ["72......"] = {"CONCAT - String concat", "a .. b"},
        ["78......"] = {"CALL - Function call", "func()"},
        ["7E......"] = {"RETURN - Return", "return x"},
        ["84......"] = {"JUMP - Unconditional jump", "goto"},
        ["8A......"] = {"EQ - Equal compare", "a == b"},
        ["90......"] = {"LT - Less than", "a < b"},
        ["96......"] = {"LE - Less or equal", "a <= b"},
        ["9C......"] = {"TEST - Boolean test", "if x then"},
        ["A2......"] = {"TESTSET - Test and set", "x = y or z"},
        ["A8......"] = {"FORLOOP - For loop", "for i = 1,10"},
        ["AE......"] = {"TFORLOOP - Generic for", "for k,v in pairs"},
        ["B4......"] = {"CLOSURE - Create function", "function() end"},
    }
    
    -- Common constant patterns
    self.constantPatterns = {
        ["00"] = "nil",
        ["01"] = "false", 
        ["02"] = "true",
        ["03......"] = "number",  -- Followed by float bytes
        ["04......"] = "string",  -- Followed by length + chars
    }
    
    return self
end

-- Attempt to decode bytecode hex
function BytecodeDecoder:decodeBytecode(hex)
    if not hex or #hex < 10 then
        return {"-- Bytecode too short"}
    end
    
    local output = {}
    table.insert(output, "üîê ATTEMPTING BYTECODE DECODING")
    table.insert(output, "Length: " .. #hex .. " hex chars (" .. math.floor(#hex/2) .. " bytes)")
    table.insert(output, "")
    
    -- Check for Luau header
    local header = hex:sub(1, 8)
    if header == "1B4C7561" then
        table.insert(output, "‚úÖ Luau bytecode signature found")
    else
        table.insert(output, "‚ö†Ô∏è  Unknown header: " .. header)
    end
    table.insert(output, "")
    
    -- Try to identify patterns
    table.insert(output, "üîç PATTERN ANALYSIS:")
    
    local patternsFound = {}
    
    -- Scan for known opcode patterns
    for pattern, info in pairs(self.opcodePatterns) do
        local pos = 1
        while pos do
            pos = hex:find(pattern, pos)
            if pos then
                local context = hex:sub(math.max(1, pos-16), math.min(#hex, pos+32))
                table.insert(patternsFound, {
                    position = pos,
                    pattern = pattern,
                    meaning = info[2],
                    context = context
                })
                pos = pos + 1
            end
        end
    end
    
    -- Sort by position
    table.sort(patternsFound, function(a, b)
        return a.position < b.position
    end)
    
    -- Show top patterns
    for i = 1, math.min(15, #patternsFound) do
        local p = patternsFound[i]
        table.insert(output, string.format("  [0x%06X] %-20s ‚Üí %s", 
            p.position, p.pattern, p.meaning))
        
        -- Show context for interesting patterns
        if p.meaning:find("LOAD") or p.meaning:find("CALL") or p.meaning:find("JUMP") then
            table.insert(output, string.format("        Context: %s", p.context))
        end
    end
    
    if #patternsFound == 0 then
        table.insert(output, "  No known patterns found")
    end
    table.insert(output, "")
    
    -- Extract string constants more aggressively
    table.insert(output, "üî§ STRING EXTRACTION ATTEMPT:")
    
    local stringsFound = {}
    
    -- Method 1: Look for string length patterns (04 followed by length in hex)
    for i = 1, #hex - 6, 2 do
        if hex:sub(i, i+1) == "04" then  -- String marker
            -- Next 4 bytes might be length (little-endian)
            local lenHex = hex:sub(i+2, i+9)
            local length = tonumber(lenHex:sub(7,8) .. lenHex:sub(5,6) .. lenHex:sub(3,4) .. lenHex:sub(1,2), 16)
            
            if length and length > 0 and length < 100 then
                -- Try to extract the string
                local strStart = i + 10
                local strEnd = strStart + (length * 2) - 1
                
                if strEnd <= #hex then
                    local strHex = hex:sub(strStart, strEnd)
                    local str = self:hexToString(strHex)
                    
                    if #str == length then  -- Valid extraction
                        table.insert(stringsFound, {
                            position = i,
                            length = length,
                            value = str
                        })
                    end
                end
            end
        end
    end
    
    -- Method 2: Look for ASCII sequences directly
    local asciiStrings = self:extractASCIIStrings(hex)
    for _, str in ipairs(asciiStrings) do
        if #str.value >= 3 then
            table.insert(stringsFound, str)
        end
    end
    
    -- Remove duplicates
    local uniqueStrings = {}
    for _, str in ipairs(stringsFound) do
        uniqueStrings[str.value] = str
    end
    
    -- Display found strings
    local sortedStrings = {}
    for _, str in pairs(uniqueStrings) do
        table.insert(sortedStrings, str)
    end
    
    table.sort(sortedStrings, function(a, b)
        return #a.value > #b.value  -- Longest first
    end)
    
    for i = 1, math.min(20, #sortedStrings) do
        local str = sortedStrings[i]
        table.insert(output, string.format("  [0x%06X] %-3d chars: \"%s\"", 
            str.position, #str.value, str.value))
    end
    
    if #sortedStrings == 0 then
        table.insert(output, "  No strings extracted")
    end
    table.insert(output, "")
    
    -- Attempt to reconstruct some code structure
    table.insert(output, "üèóÔ∏è  CODE STRUCTURE GUESS:")
    
    local guesses = {}
    
    -- Look for function call patterns
    if hex:find("78......") then  -- CALL opcode
        -- Check what comes before the call (might be what's being called)
        for pos in hex:gmatch("()78......") do
            local before = hex:sub(math.max(1, pos-20), pos-1)
            
            -- Try to find a string before the call
            for _, str in ipairs(sortedStrings) do
                if str.position < pos and pos - str.position < 50 then
                    table.insert(guesses, "CALL: " .. str.value .. "()")
                    break
                end
            end
        end
    end
    
    -- Look for table access
    if hex:find("42......") then  -- GETTABLE
        table.insert(guesses, "Table access: x.y or x[y]")
    end
    
    -- Look for loops
    if hex:find("A8......") then  -- FORLOOP
        table.insert(guesses, "For loop: for i = ...")
    end
    
    -- Look for comparisons
    if hex:find("8A......") or hex:find("90......") or hex:find("96......") then
        table.insert(guesses, "Comparison: a == b or a < b")
    end
    
    -- Display guesses
    if #guesses > 0 then
        for i, guess in ipairs(guesses) do
            table.insert(output, "  ‚Ä¢ " .. guess)
        end
    else
        table.insert(output, "  Could not guess code structure")
    end
    
    return output
end

-- Convert hex to ASCII string
function BytecodeDecoder:hexToString(hex)
    local str = ""
    for i = 1, #hex, 2 do
        local byteHex = hex:sub(i, i+1)
        local byte = tonumber(byteHex, 16)
        if byte and byte >= 32 and byte <= 126 then
            str = str .. string.char(byte)
        else
            return str  -- Stop at first non-ASCII
        end
    end
    return str
end

-- Extract ASCII strings from hex
function BytecodeDecoder:extractASCIIStrings(hex)
    local strings = {}
    local i = 1
    
    while i <= #hex do
        -- Look for start of ASCII sequence
        if tonumber(hex:sub(i, i+1), 16) and tonumber(hex:sub(i, i+1), 16) >= 65 then  -- A or higher
            local start = i
            local strHex = ""
            local valid = true
            
            -- Collect consecutive ASCII characters
            while valid and i <= #hex - 1 do
                local byte = tonumber(hex:sub(i, i+1), 16)
                if byte and byte >= 32 and byte <= 126 then
                    strHex = strHex .. hex:sub(i, i+1)
                    i = i + 2
                else
                    valid = false
                end
            end
            
            if #strHex >= 6 then  -- At least 3 characters
                local str = self:hexToString(strHex)
                if #str >= 3 then
                    table.insert(strings, {
                        position = start,
                        value = str
                    })
                end
            end
        else
            i = i + 2
        end
    end
    
    return strings
end

-- Analyze a specific script with decoding
function BytecodeDecoder:analyzeWithDecoding(script)
    local output = {}
    
    table.insert(output, "=" .. string.rep("=", 60))
    table.insert(output, "üîê BYTECODE DECODING ATTEMPT")
    table.insert(output, "Script: " .. script:GetFullName())
    table.insert(output, "=" .. string.rep("=", 60))
    table.insert(output, "")
    
    -- Get bytecode
    local bytecodeSuccess, bytecode = pcall(getscriptbytecode, script)
    if not bytecodeSuccess or not bytecode then
        table.insert(output, "‚ùå Could not get bytecode")
        return table.concat(output, "\n")
    end
    
    -- Try to decode
    local decoded = self:decodeBytecode(bytecode)
    for _, line in ipairs(decoded) do
        table.insert(output, line)
    end
    
    table.insert(output, "")
    table.insert(output, "=" .. string.rep("=", 60))
    
    return table.concat(output, "\n")
end

-- ========== MAIN: DECODE WEAPON SERVICE ==========
print("üîê ATTEMPTING BYTECODE DECODING")
print("This will try to decode hex bytecode into Lua-like structures")
print("")

local decoder = BytecodeDecoder.new()

-- Try to decode the WeaponService module
local target = game:GetService("ReplicatedStorage"):FindFirstChild("ClientServices")
if target then
    local weaponService = target:FindFirstChild("WeaponService")
    if weaponService and weaponService:IsA("ModuleScript") then
        print("üéØ TARGET: WeaponService ModuleScript")
        local result = decoder:analyzeWithDecoding(weaponService)
        
        -- Save to file
        local fileName = "bytecode_decode_" .. os.time() .. ".txt"
        
        if type(writefile) == "function" then
            pcall(writefile, fileName, result)
            print("‚úÖ Saved to: " .. fileName)
            
            -- Show preview
            print("\nüìÑ DECODING PREVIEW:")
            print(string.rep("-", 50))
            
            local lines = {}
            for line in result:gmatch("[^\r\n]+") do
                table.insert(lines, line)
                if #lines >= 25 then break end
            end
            print(table.concat(lines, "\n"))
            if #lines >= 25 then print("... (full in file)") end
            
        else
            print("\nüìÑ OUTPUT:")
            print(string.rep("-", 50))
            print(result:sub(1, 1000))
            if #result > 1000 then print("...") end
        end
    else
        print("‚ùå WeaponService not found")
    end
else
    print("‚ùå ClientServices not found")
end

print("\n" .. string.rep("=", 50))
print("Note: This is GUESSWORK based on reverse-engineering!")
print("Real decompilation requires Luau VM knowledge.")
