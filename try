-- PROPER BYTECODE ANALYZER - Handles C/Lua closures correctly
local BytecodeAnalyzer = {}
BytecodeAnalyzer.__index = BytecodeAnalyzer

function BytecodeAnalyzer.new()
    local self = setmetatable({}, BytecodeAnalyzer)
    
    self.gameKeywords = {
        "Gun", "Knife", "Shoot", "Fire", "Bullet", "Ammo", "Reload",
        "Damage", "Hit", "Kill", "Murder", "Sheriff", "Trade", "Offer",
        "Round", "Role", "Coin", "XP", "Level", "Prestige", "Event"
    }
    
    return self
end

-- Safe debug.getinfo that works with C closures
function BytecodeAnalyzer:safeGetInfo(closure)
    if not closure then return nil end
    
    -- Check if it's a C closure (which debug.getinfo can't handle well)
    local isC = false
    if iscclosure then
        isC = iscclosure(closure)
    end
    
    local info = {}
    
    if not isC then
        -- Lua closure - we can use debug.getinfo
        local success, result = pcall(debug.getinfo, closure)
        if success then
            info = result or {}
        end
    else
        -- C closure - minimal info
        info.what = "C"
        info.source = "[C]"
    end
    
    -- Add type info if available
    if islclosure then
        info.lclosure = islclosure(closure)
    end
    if iscclosure then
        info.cclosure = iscclosure(closure)
    end
    
    return info
end

-- Extract constants safely
function BytecodeAnalyzer:extractConstants(closure)
    local output = {}
    
    if not closure then
        table.insert(output, "-- No closure provided")
        return output
    end
    
    local success, constants = pcall(debug.getconstants, closure)
    if not success or not constants then
        table.insert(output, "-- Could not extract constants")
        return output
    end
    
    table.insert(output, "üì¶ CONSTANTS FOUND: " .. #constants)
    
    -- Group by type and highlight game keywords
    local gameStrings = {}
    local otherStrings = {}
    local numbers = {}
    
    for i = 1, math.min(50, #constants) do  -- Limit to 50
        local const = constants[i]
        local constType = type(const)
        
        if constType == "string" and #const > 0 and #const < 50 then
            -- Check if it's game-related
            local isGame = false
            for _, keyword in ipairs(self.gameKeywords) do
                if const:find(keyword) then
                    isGame = true
                    break
                end
            end
            
            if const:match("^[%a_][%w_]*$") then  -- Valid identifier
                if isGame then
                    table.insert(gameStrings, {index = i, value = const})
                else
                    table.insert(otherStrings, {index = i, value = const})
                end
            end
            
        elseif constType == "number" then
            -- Only show interesting numbers
            if const == 0 or const == 1 or const == 100 or const == 1000 or 
               const == -1 or const == 0.5 or const == 0.25 or const == 16 then
                table.insert(numbers, {index = i, value = const})
            end
        end
    end
    
    -- Output game strings first (most important)
    if #gameStrings > 0 then
        table.insert(output, "")
        table.insert(output, "üéØ GAME-RELATED STRINGS:")
        for _, item in ipairs(gameStrings) do
            table.insert(output, string.format("  [%3d] \"%s\"", item.index, item.value))
        end
    end
    
    -- Other strings
    if #otherStrings > 0 then
        table.insert(output, "")
        table.insert(output, "üî§ OTHER IDENTIFIERS:")
        for i = 1, math.min(10, #otherStrings) do  -- Limit others
            local item = otherStrings[i]
            table.insert(output, string.format("  [%3d] \"%s\"", item.index, item.value))
        end
        if #otherStrings > 10 then
            table.insert(output, string.format("  ... and %d more", #otherStrings - 10))
        end
    end
    
    -- Numbers
    if #numbers > 0 then
        table.insert(output, "")
        table.insert(output, "üî¢ NUMBERS:")
        for _, item in ipairs(numbers) do
            table.insert(output, string.format("  [%3d] %s", item.index, tostring(item.value)))
        end
    end
    
    -- Count other types
    local boolCount, nilCount = 0, 0
    for i = 1, math.min(50, #constants) do
        local const = constants[i]
        if type(const) == "boolean" then boolCount = boolCount + 1 end
        if const == nil then nilCount = nilCount + 1 end
    end
    
    if boolCount > 0 then
        table.insert(output, "")
        table.insert(output, "üîò BOOLEANS: " .. boolCount)
    end
    
    if nilCount > 0 then
        table.insert(output, "")
        table.insert(output, "‚óªÔ∏è  NILS: " .. nilCount)
    end
    
    return output
end

-- Analyze bytecode hex for strings
function BytecodeAnalyzer:scanBytecodeForStrings(bytecode)
    if not bytecode or #bytecode < 20 then
        return {"-- Bytecode too short or missing"}
    end
    
    local output = {}
    local found = {}
    
    -- Look for ASCII strings in hex (pairs of hex digits)
    for i = 1, #bytecode - 3, 2 do
        local startHex = bytecode:sub(i, i+1)
        local startDec = tonumber(startHex, 16)
        
        if startDec and startDec >= 65 and startDec <= 90 then  -- A-Z
            -- Try to read a string
            local str = ""
            local valid = true
            local j = i
            
            while valid and j <= #bytecode - 1 and #str < 30 do
                local hexPair = bytecode:sub(j, j+1)
                local dec = tonumber(hexPair, 16)
                
                if dec and dec >= 32 and dec <= 126 then  -- Printable ASCII
                    str = str .. string.char(dec)
                    j = j + 2
                else
                    valid = false
                end
            end
            
            if #str >= 3 and #str <= 25 then
                -- Check if it looks like code/identifier
                if str:match("^[%a_][%w_]*$") and not str:match("^%x+$") then
                    if not found[str] then
                        found[str] = true
                        
                        -- Check if game-related
                        local isGame = false
                        for _, keyword in ipairs(self.gameKeywords) do
                            if str:find(keyword) then
                                isGame = true
                                break
                            end
                        end
                        
                        if isGame then
                            table.insert(output, "üéØ \"" .. str .. "\"")
                        elseif str:find("^[A-Z]") then  -- PascalCase
                            table.insert(output, "  \"" .. str .. "\"")
                        end
                    end
                end
            end
        end
    end
    
    if #output == 0 then
        table.insert(output, "-- No readable strings found in bytecode")
    end
    
    return output
end

-- Main analysis for a single script
function BytecodeAnalyzer:analyzeScript(script)
    local output = {}
    
    table.insert(output, "=" .. string.rep("=", 50))
    table.insert(output, "üîç ANALYZING: " .. script:GetFullName())
    table.insert(output, "Type: " .. script.ClassName)
    table.insert(output, "=" .. string.rep("=", 50))
    table.insert(output, "")
    
    -- 1. Try to get bytecode
    local bytecodeSuccess, bytecode = pcall(getscriptbytecode, script)
    if bytecodeSuccess and bytecode then
        table.insert(output, "üìä BYTECODE INFO:")
        table.insert(output, "  Size: " .. #bytecode .. " bytes")
        table.insert(output, "")
        
        -- Scan for strings in bytecode
        local bytecodeStrings = self:scanBytecodeForStrings(bytecode)
        if #bytecodeStrings > 0 then
            table.insert(output, "üî§ STRINGS IN BYTECODE:")
            for _, line in ipairs(bytecodeStrings) do
                table.insert(output, "  " .. line)
            end
            table.insert(output, "")
        end
        
        -- Show hex preview
        table.insert(output, "üî¢ HEX PREVIEW (first 100 chars):")
        local preview = bytecode:sub(1, 100)
        if #bytecode > 100 then preview = preview .. "..." end
        table.insert(output, "  " .. preview)
        table.insert(output, "")
    else
        table.insert(output, "üìä BYTECODE: Not available")
        table.insert(output, "")
    end
    
    -- 2. Try to get closure
    local closureSuccess, closure = pcall(getscriptclosure, script)
    if closureSuccess and closure then
        table.insert(output, "‚öôÔ∏è CLOSURE ANALYSIS:")
        
        -- Get closure type
        if iscclosure and islclosure then
            if iscclosure(closure) then
                table.insert(output, "  Type: C Closure")
            elseif islclosure(closure) then
                table.insert(output, "  Type: Lua Closure")
            end
        end
        
        -- Extract constants
        local constantsOutput = self:extractConstants(closure)
        for _, line in ipairs(constantsOutput) do
            table.insert(output, line)
        end
        table.insert(output, "")
        
        -- Try to get some debug info (safely)
        local info = self:safeGetInfo(closure)
        if info and (info.source or info.what) then
            table.insert(output, "üìù DEBUG INFO:")
            if info.source and info.source ~= "[C]" then
                table.insert(output, "  Source: " .. info.source)
            end
            if info.what then
                table.insert(output, "  What: " .. info.what)
            end
            if info.currentline then
                table.insert(output, "  Line: " .. info.currentline)
            end
            table.insert(output, "")
        end
        
    else
        table.insert(output, "‚öôÔ∏è CLOSURE: Not available")
        table.insert(output, "")
    end
    
    -- 3. For ModuleScripts, show source
    if script:IsA("ModuleScript") and script.Source and #script.Source > 0 then
        table.insert(output, "üìÑ SOURCE CODE PREVIEW:")
        table.insert(output, string.rep("-", 40))
        
        -- Count lines and show first 10
        local lineCount = 0
        for _ in script.Source:gmatch("\n") do
            lineCount = lineCount + 1
        end
        lineCount = lineCount + 1  -- Add last line
        
        table.insert(output, "  Total lines: " .. lineCount)
        table.insert(output, "  Total chars: " .. #script.Source)
        table.insert(output, "")
        
        if #script.Source > 0 then
            local lines = {}
            for line in script.Source:gmatch("[^\r\n]+") do
                table.insert(lines, line)
                if #lines >= 10 then break end
            end
            
            for i, line in ipairs(lines) do
                -- Truncate long lines
                if #line > 80 then
                    line = line:sub(1, 77) .. "..."
                end
                table.insert(output, string.format("  %3d: %s", i, line))
            end
            
            if lineCount > 10 then
                table.insert(output, string.format("  ... and %d more lines", lineCount - 10))
            end
        end
        table.insert(output, "")
    end
    
    table.insert(output, "=" .. string.rep("=", 50))
    
    return table.concat(output, "\n")
end

-- Find and analyze key scripts from your game
function BytecodeAnalyzer:analyzeKeyScripts()
    local output = {}
    local targets = {}
    
    table.insert(output, "üéÆ GAME BYTECODE ANALYSIS")
    table.insert(output, "Time: " .. os.date("%H:%M:%S"))
    table.insert(output, "")
    
    -- Look for specific scripts based on your game structure
    local rs = game:GetService("ReplicatedStorage")
    
    -- Priority 1: Weapon-related ModuleScripts
    local modules = rs:FindFirstChild("Modules")
    if modules then
        for _, module in pairs(modules:GetChildren()) do
            if module:IsA("ModuleScript") then
                if module.Name:find("Weapon") or 
                   module.Name:find("Gun") or 
                   module.Name:find("Knife") then
                    table.insert(targets, {
                        name = module.Name,
                        script = module,
                        priority = 10
                    })
                elseif module.Name:find("Service") or module.Name:find("System") then
                    table.insert(targets, {
                        name = module.Name,
                        script = module,
                        priority = 5
                    })
                end
            end
        end
    end
    
    -- Priority 2: ClientServices
    local clientServices = rs:FindFirstChild("ClientServices")
    if clientServices then
        for _, service in pairs(clientServices:GetChildren()) do
            if service:IsA("ModuleScript") and service.Name:find("Weapon") then
                table.insert(targets, {
                    name = "ClientServices." .. service.Name,
                    script = service,
                    priority = 9
                })
            end
        end
    end
    
    -- Priority 3: Player's current tool
    local player = game.Players.LocalPlayer
    if player and player.Character then
        for _, child in pairs(player.Character:GetChildren()) do
            if child:IsA("Tool") then
                -- Look for scripts in the tool
                for _, scriptChild in pairs(child:GetDescendants()) do
                    if scriptChild:IsA("Script") or scriptChild:IsA("LocalScript") then
                        if scriptChild.Name:find("Client") then
                            table.insert(targets, {
                                name = "Tool." .. child.Name .. "." .. scriptChild.Name,
                                script = scriptChild,
                                priority = 8
                            })
                        end
                    end
                end
            end
        end
    end
    
    -- Sort by priority
    table.sort(targets, function(a, b)
        return a.priority > b.priority
    end)
    
    -- Analyze found targets
    if #targets == 0 then
        table.insert(output, "‚ö†Ô∏è No specific targets found, analyzing random ModuleScripts...")
        
        -- Fallback: analyze first 2 ModuleScripts
        local count = 0
        for _, item in pairs(rs:GetChildren()) do
            if item:IsA("ModuleScript") and count < 2 then
                table.insert(output, "")
                local analysis = self:analyzeScript(item)
                table.insert(output, analysis)
                count = count + 1
            end
        end
        
        if count == 0 then
            table.insert(output, "‚ùå No ModuleScripts found at all!")
        end
    else
        table.insert(output, "üìã FOUND " .. #targets .. " TARGET SCRIPTS:")
        for i, target in ipairs(targets) do
            table.insert(output, string.format("  %d. %s (Priority: %d)", i, target.name, target.priority))
        end
        table.insert(output, "")
        
        -- Analyze top 3 targets
        for i = 1, math.min(3, #targets) do
            local target = targets[i]
            table.insert(output, "")
            table.insert(output, "üöÄ ANALYZING TARGET #" .. i .. ": " .. target.name)
            
            local analysis = self:analyzeScript(target.script)
            table.insert(output, analysis)
        end
    end
    
    return table.concat(output, "\n")
end

-- ========== MAIN EXECUTION ==========
print("üîç PROPER BYTECODE ANALYZER")
print("This will extract REAL strings and constants from scripts")
print("")

local analyzer = BytecodeAnalyzer.new()
local result = analyzer:analyzeKeyScripts()

-- Save to file
local fileName = "bytecode_extract_" .. os.time() .. ".txt"

if type(writefile) == "function" then
    local success, err = pcall(writefile, fileName, result)
    if success then
        print("‚úÖ Saved to: " .. fileName)
        
        -- Show preview
        print("\nüìÑ PREVIEW (first 30 lines):")
        print(string.rep("-", 50))
        
        local lines = {}
        for line in result:gmatch("[^\r\n]+") do
            table.insert(lines, line)
            if #lines >= 30 then break end
        end
        
        print(table.concat(lines, "\n"))
        if #lines >= 30 then
            print("... (full output in file)")
        end
        
    else
        print("‚ùå Save failed: " .. tostring(err))
        print("\nüìã OUTPUT PREVIEW:")
        print(string.rep("-", 50))
        print(result:sub(1, 800))
        if #result > 800 then print("...") end
    end
else
    print("‚ö†Ô∏è  writefile not available")
    print("\nüìã OUTPUT:")
    print(string.rep("-", 50))
    print(result)
end

print("\n" .. string.rep("=", 50))
print("Done! Check the file for extracted strings and constants.")
