-- Performance Monitor & Exploit Sniffer
-- Run this IN YOUR EXPLOIT before executing the hub script

local Stats = game:GetService("Stats")
local NetworkClient = game:GetService("NetworkClient")
local RunService = game:GetService("RunService")

-- Configuration
local MONITOR_DURATION = 10  -- How long to monitor (seconds)
local PING_THRESHOLD = 200   -- Ping spike threshold (ms)
local FPS_THRESHOLD = 15     -- Minimum FPS to trigger alert
local MEMORY_SPIKE_MB = 50   -- Memory spike threshold (MB)

-- Tracking variables
local baselinePing = 0
local baselineMemory = 0
local maxPing = 0
local maxMemory = 0
local minFPS = 60
local performanceLogs = {}
local hookedFunctions = {}

-- 1. PERFORMANCE MONITORING FUNCTIONS
local function getCurrentPing()
    return NetworkClient:GetServerResponseTime() * 1000  -- Convert to ms
end

local function getCurrentMemory()
    return Stats:GetTotalMemoryUsageMb()
end

local function getCurrentFPS()
    return 1 / RunService.RenderStepped:Wait()
end

-- 2. FUNCTION HOOK TRACKING (see what the exploit uses)
local function setupFunctionTracker()
    local sensitiveFunctions = {
        hookfunction = hookfunction,
        hookmetamethod = hookmetamethod,
        getgenv = getgenv,
        getrenv = getrenv,
        getrawmetatable = getrawmetatable,
        setreadonly = setreadonly,
        debug_getupvalues = debug.getupvalues,
        debug_getconstants = debug.getconstants
    }
    
    for funcName, func in pairs(sensitiveFunctions) do
        if func then
            local original = func
            hookedFunctions[funcName] = original
            
            -- Replace with tracking wrapper
            local function tracker(...)
                local callTime = os.clock()
                local result = original(...)
                
                table.insert(performanceLogs, {
                    time = callTime,
                    type = "FUNCTION_CALL",
                    function = funcName,
                    args = {...},
                    ping = getCurrentPing(),
                    memory = getCurrentMemory()
                })
                
                print(string.format("[TRACKER] %s() called at %.2fs", funcName, callTime))
                return result
            end
            
            -- Apply hook if we're in exploiter context
            if funcName == "hookfunction" then
                hookfunction = tracker
            elseif funcName == "getgenv" then
                getgenv = tracker
            end
            -- Add more as needed...
        end
    end
end

-- 3. MAIN MONITORING LOOP
local function startPerformanceMonitor()
    print("=== PERFORMANCE MONITOR STARTED ===")
    print("Monitoring for", MONITOR_DURATION, "seconds...")
    
    -- Establish baseline (first 2 seconds)
    local baselines = {}
    for i = 1, 40 do  -- 2 seconds of samples
        table.insert(baselines, {
            ping = getCurrentPing(),
            memory = getCurrentMemory(),
            fps = getCurrentFPS()
        })
        task.wait(0.05)
    end
    
    -- Calculate averages
    local totalPing, totalMemory, totalFPS = 0, 0, 0
    for _, sample in ipairs(baselines) do
        totalPing = totalPing + sample.ping
        totalMemory = totalMemory + sample.memory
        totalFPS = totalFPS + sample.fps
    end
    
    baselinePing = totalPing / #baselines
    baselineMemory = totalMemory / #baselines
    local baselineFPS = totalFPS / #baselines
    
    print(string.format("Baselines established: Ping=%.1fms, Memory=%.1fMB, FPS=%.1f", 
        baselinePing, baselineMemory, baselineFPS))
    
    -- Start tracking
    local startTime = os.clock()
    local alertTriggered = false
    
    while os.clock() - startTime < MONITOR_DURATION do
        local currentTime = os.clock() - startTime
        local ping = getCurrentPing()
        local memory = getCurrentMemory()
        local fps = getCurrentFPS()
        
        -- Track extremes
        if ping > maxPing then maxPing = ping end
        if memory > maxMemory then maxMemory = memory end
        if fps < minFPS then minFPS = fps end
        
        -- Detect anomalies
        local anomalies = {}
        
        if ping > baselinePing + PING_THRESHOLD then
            table.insert(anomalies, string.format("PING SPIKE: %.1fms (+%.1f)", ping, ping - baselinePing))
        end
        
        if memory > baselineMemory + MEMORY_SPIKE_MB then
            table.insert(anomalies, string.format("MEMORY SPIKE: %.1fMB (+%.1f)", memory, memory - baselineMemory))
        end
        
        if fps < FPS_THRESHOLD then
            table.insert(anomalies, string.format("FPS DROP: %.1f (baseline %.1f)", fps, baselineFPS))
        end
        
        -- Log performance sample
        local sample = {
            time = currentTime,
            ping = ping,
            memory = memory,
            fps = fps,
            anomalies = #anomalies > 0 and anomalies or nil
        }
        
        table.insert(performanceLogs, sample)
        
        -- Alert if anomalies detected
        if #anomalies > 0 and not alertTriggered then
            alertTriggered = true
            print("\n‚ö†Ô∏è  PERFORMANCE ANOMALIES DETECTED ‚ö†Ô∏è")
            for _, anomaly in ipairs(anomalies) do
                print("   " .. anomaly)
            end
            print("   Time:", string.format("%.2fs", currentTime))
        end
        
        task.wait(0.1)  -- Sample every 100ms
    end
    
    -- 4. GENERATE FINAL REPORT
    print("\n" .. string.rep("=", 50))
    print("FINAL PERFORMANCE REPORT")
    print(string.rep("=", 50))
    
    print(string.format("Monitoring Duration: %.1f seconds", MONITOR_DURATION))
    print(string.format("Baseline Ping: %.1fms", baselinePing))
    print(string.format("Maximum Ping: %.1fms (Œî%.1fms)", maxPing, maxPing - baselinePing))
    print(string.format("Baseline Memory: %.1fMB", baselineMemory))
    print(string.format("Maximum Memory: %.1fMB (Œî%.1fMB)", maxMemory, maxMemory - baselineMemory))
    print(string.format("Minimum FPS: %.1f", minFPS))
    
    -- Find the worst performance period
    local worstTime = 0
    local worstSeverity = 0
    
    for _, log in ipairs(performanceLogs) do
        if log.anomalies then
            local severity = 0
            if log.ping > baselinePing + PING_THRESHOLD then severity = severity + 1 end
            if log.memory > baselineMemory + MEMORY_SPIKE_MB then severity = severity + 1 end
            if log.fps < FPS_THRESHOLD then severity = severity + 1 end
            
            if severity > worstSeverity then
                worstSeverity = severity
                worstTime = log.time
            end
        end
    end
    
    if worstSeverity > 0 then
        print(string.format("\n‚ö†Ô∏è  WORST PERFORMANCE AT: %.2f seconds", worstTime))
        print("   (This is likely when the exploit was loading)")
    end
    
    -- Show function calls if tracking was set up
    local functionCalls = 0
    for _, log in ipairs(performanceLogs) do
        if log.type == "FUNCTION_CALL" then
            functionCalls = functionCalls + 1
        end
    end
    
    if functionCalls > 0 then
        print(string.format("\nüîç DETECTED %d SUSPICIOUS FUNCTION CALLS", functionCalls))
        for _, log in ipairs(performanceLogs) do
            if log.type == "FUNCTION_CALL" then
                print(string.format("   [%.2fs] %s()", log.time, log.function))
            end
        end
    end
    
    print("\n" .. string.rep("=", 50))
    
    -- 5. SAVE DATA FOR ANALYSIS (optional)
    local function exportData()
        local export = "Time,Ping,Memory,FPS,Anomalies\n"
        for _, log in ipairs(performanceLogs) do
            export = export .. string.format("%.2f,%.1f,%.1f,%.1f,%s\n",
                log.time, log.ping or 0, log.memory or 0, log.fps or 0,
                log.anomalies and table.concat(log.anomalies, "; ") or ""
            )
        end
        return export
    end
    
    -- Save to file if writefile is available
    if writefile then
        writefile("performance_log.csv", exportData())
        print("üìä Data saved to 'performance_log.csv'")
    end
    
    return performanceLogs
end

-- 6. EXECUTION INSTRUCTIONS
print([[
=== ECLIPSE HUB PERFORMANCE SNIFFER ===

INSTRUCTIONS:
1. Run this script FIRST in your executor
2. Wait for "PERFORMANCE MONITOR STARTED" message
3. THEN run your Eclipse Hub script
4. Monitor will run for 10 seconds and generate a report

The script will:
‚Ä¢ Track ping, memory, and FPS
‚Ä¢ Detect performance spikes (like the 4.6s freeze)
‚Ä¢ Log suspicious function calls
‚Ä¢ Generate a detailed report

Press any key to begin...
]])

-- Wait for user input
task.wait(2)

-- Setup tracking and start monitor
pcall(setupFunctionTracker)
local logs = startPerformanceMonitor()

-- Optional: Auto-analyze for exploit patterns
local function analyzeForExploitPatterns()
    local freezeDetected = false
    local freezeStart = 0
    
    for i = 2, #logs do
        local prev = logs[i-1]
        local curr = logs[i]
        
        -- Detect sudden FPS drop followed by recovery (freeze pattern)
        if curr.fps and prev.fps and curr.fps < 5 and prev.fps > 20 then
            freezeStart = curr.time
        end
        
        if freezeStart > 0 and curr.fps > 20 and curr.time - freezeStart > 3 then
            freezeDetected = true
            print(string.format("\nüéØ DETECTED EXPLOIT LOADING FREEZE: %.2f second freeze at %.2fs", 
                curr.time - freezeStart, freezeStart))
            break
        end
    end
    
    return freezeDetected
end

if analyzeForExploitPatterns() then
    print("‚úÖ Exploit loading signature detected!")
end
