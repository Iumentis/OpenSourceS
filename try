-- MURDER MYSTERY 2-STYLE GAME DECOMPILER HELPER
local GameDecompiler = {}
GameDecompiler.__index = GameDecompiler

function GameDecompiler.new()
    local self = setmetatable({}, GameDecompiler)
    
    -- TARGET SPECIFIC PATHS BASED ON YOUR GAME STRUCTURE
    self.targetPaths = {
        -- Weapon systems (MOST IMPORTANT)
        weapons = {
            "ReplicatedStorage.Modules.WeaponSystem",
            "ReplicatedStorage.WeaponEvents",
            "Players.*.Backpack.*",  -- Player weapons
            "Workspace.*.Knife",     -- Knife tools
            "Workspace.*.Gun",       -- Gun tools
        },
        
        -- Trading system
        trading = {
            "ReplicatedStorage.Remotes",  -- All trade remotes
            "ReplicatedStorage.Modules.Trading",
        },
        
        -- Game logic
        gameLogic = {
            "ReplicatedStorage.Modules.GameMode",
            "ReplicatedStorage.SharedServices",
            "ReplicatedStorage.ClientServices",
        },
        
        -- Anti-cheat/security
        security = {
            "ReplicatedStorage.Modules.AntiCheat",
            "ReplicatedStorage.ClientServices.WeaponService",
        }
    }
    
    return self
end

-- Find all target scripts automatically
function GameDecompiler:findTargetScripts()
    local targets = {}
    
    print("ğŸ” Searching for game-specific scripts...")
    
    -- 1. WEAPON SYSTEMS (Priority #1)
    local weaponModules = game:GetService("ReplicatedStorage"):FindFirstChild("Modules")
    if weaponModules then
        local weaponSystem = weaponModules:FindFirstChild("WeaponSystem")
        if weaponSystem and weaponSystem:IsA("ModuleScript") then
            table.insert(targets, {
                name = "WeaponSystem",
                script = weaponSystem,
                priority = 10,
                type = "weapon"
            })
        end
        
        -- Check for other weapon-related modules
        for _, module in pairs(weaponModules:GetChildren()) do
            if module:IsA("ModuleScript") and (
                module.Name:find("Weapon") or 
                module.Name:find("Gun") or
                module.Name:find("Knife")
            ) then
                table.insert(targets, {
                    name = module.Name,
                    script = module,
                    priority = 8,
                    type = "weapon"
                })
            end
        end
    end
    
    -- 2. WEAPON EVENTS FOLDER
    local weaponEvents = game:GetService("ReplicatedStorage"):FindFirstChild("WeaponEvents")
    if weaponEvents then
        for _, remote in pairs(weaponEvents:GetChildren()) do
            if remote:IsA("RemoteEvent") and remote.Name:find("Gun") then
                -- Look for associated scripts
                local parent = remote.Parent
                while parent and parent ~= game do
                    local scripts = parent:GetChildren()
                    for _, script in pairs(scripts) do
                        if script:IsA("Script") or script:IsA("LocalScript") then
                            if script.Name:find("Client") or script.Name:find("Server") then
                                table.insert(targets, {
                                    name = remote.Name .. "_" .. script.Name,
                                    script = script,
                                    priority = 9,
                                    type = "weapon_remote"
                                })
                            end
                        end
                    end
                    parent = parent.Parent
                end
            end
        end
    end
    
    -- 3. PLAYER WEAPON (Knife from your scan)
    local localPlayer = game:GetService("Players").LocalPlayer
    if localPlayer.Character then
        for _, tool in pairs(localPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") and (tool.Name == "Knife" or tool.Name:find("Gun")) then
                -- Look for client scripts in the tool
                for _, script in pairs(tool:GetDescendants()) do
                    if (script:IsA("Script") or script:IsA("LocalScript")) and 
                       script.Name:find("Client") then
                        table.insert(targets, {
                            name = "Tool_" .. tool.Name .. "_" .. script.Name,
                            script = script,
                            priority = 10,  -- Highest priority
                            type = "tool_client"
                        })
                    end
                end
            end
        end
    end
    
    -- 4. GunFired RemoteEvent handling
    local gunFired = game:GetService("ReplicatedStorage"):FindFirstChild("GunFired")
    if gunFired and gunFired:IsA("RemoteEvent") then
        -- Search for scripts that might handle GunFired
        local clientServices = game:GetService("ReplicatedStorage"):FindFirstChild("ClientServices")
        if clientServices then
            local weaponService = clientServices:FindFirstChild("WeaponService")
            if weaponService and weaponService:IsA("ModuleScript") then
                table.insert(targets, {
                    name = "WeaponService",
                    script = weaponService,
                    priority = 9,
                    type = "weapon_service"
                })
            end
        end
    end
    
    -- Sort by priority (highest first)
    table.sort(targets, function(a, b)
        return a.priority > b.priority
    end)
    
    return targets
end

-- Game-specific decompilation with pattern recognition
function GameDecompiler:smartDecompile(script)
    local output = {"-- GAME-SPECIFIC DECOMPILATION ANALYSIS"}
    table.insert(output, "Script: " .. script:GetFullName())
    table.insert(output, "Type: " .. script.ClassName)
    table.insert(output, "")
    
    -- Try standard decompile first
    local decompileSuccess, decompiled = pcall(function()
        return decompile(script)
    end)
    
    if decompileSuccess and decompiled and #decompiled > 100 then
        table.insert(output, "=== STANDARD DECOMPILE ===")
        table.insert(output, decompiled)
        return table.concat(output, "\n")
    end
    
    -- If standard fails, use game-specific analysis
    table.insert(output, "=== GAME-SPECIFIC ANALYSIS ===")
    
    -- Get whatever info we can
    local bytecodeSuccess, bytecode = pcall(getscriptbytecode, script)
    if bytecodeSuccess and bytecode then
        table.insert(output, "Bytecode size: " .. #bytecode .. " bytes")
        
        -- Look for game-specific patterns in bytecode
        if script:IsA("ModuleScript") and script.Name:find("Weapon") then
            table.insert(output, "")
            table.insert(output, "ğŸ”« WEAPON SYSTEM DETECTED")
            table.insert(output, "Common weapon patterns to look for:")
            table.insert(output, "1. FireServer('GunFired', ...)")
            table.insert(output, "2. Raycasting for bullet trajectories")
            table.insert(output, "3. Sound effect triggers")
            table.insert(output, "4. Animation playing")
            table.insert(output, "5. Ammo/reload logic")
        end
        
        if script.Name:find("Client") then
            table.insert(output, "")
            table.insert(output, "ğŸ’» CLIENT-SIDE SCRIPT DETECTED")
            table.insert(output, "May contain:")
            table.insert(output, "1. User input handling (mouse/keyboard)")
            table.insert(output, "2. Local visual effects")
            table.insert(output, "3. UI updates")
            table.insert(output, "4. Client-side validation")
        end
    end
    
    -- Try to get closure for deeper analysis
    local closureSuccess, closure = pcall(getscriptclosure, script)
    if closureSuccess and closure then
        table.insert(output, "")
        table.insert(output, "=== CLOSURE ANALYSIS ===")
        
        -- Extract constants
        local constSuccess, constants = pcall(debug.getconstants, closure)
        if constSuccess and constants then
            table.insert(output, "Constants found: " .. #constants)
            
            -- Filter for game-relevant strings
            local gameStrings = {}
            for _, const in pairs(constants) do
                if type(const) == "string" then
                    -- Look for weapon/trading/game-specific terms
                    if const:find("Gun") or const:find("Knife") or 
                       const:find("Fire") or const:find("Shoot") or
                       const:find("Trade") or const:find("Kill") or
                       const:find("Murder") or const:find("Sheriff") then
                        table.insert(gameStrings, const)
                    end
                end
            end
            
            if #gameStrings > 0 then
                table.insert(output, "Game-relevant strings:")
                for _, str in pairs(gameStrings) do
                    table.insert(output, "  â€¢ \"" .. str .. "\"")
                end
            end
        end
    end
    
    -- Check for source in ModuleScripts
    if script:IsA("ModuleScript") and script.Source and #script.Source > 0 then
        table.insert(output, "")
        table.insert(output, "=== MODULE SOURCE ===")
        
        -- Extract first 20 lines
        local lines = {}
        for line in script.Source:gmatch("[^\r\n]+") do
            table.insert(lines, line)
            if #lines >= 20 then break end
        end
        
        for _, line in pairs(lines) do
            table.insert(output, line)
        end
        
        if #script.Source > 20 * 80 then  -- Rough estimate
            table.insert(output, "... (source truncated)")
        end
    end
    
    -- Add exploitation hints based on script type
    table.insert(output, "")
    table.insert(output, "=== EXPLOITATION HINTS ===")
    
    if script.Name:find("Weapon") or script.Name:find("Gun") then
        table.insert(output, "ğŸ¯ WEAPON SYSTEM - POTENTIAL VULNERABILITIES:")
        table.insert(output, "1. Client-side rate limiting (spam shots)")
        table.insert(output, "2. No server-side trajectory validation")
        table.insert(output, "3. Predictable damage calculation")
        table.insert(output, "4. Local anti-cheat that can be bypassed")
        
    elseif script.Name:find("Client") then
        table.insert(output, "ğŸ¯ CLIENT SCRIPT - POTENTIAL VULNERABILITIES:")
        table.insert(output, "1. Local validation that can be bypassed")
        table.insert(output, "2. Event handlers that can be hooked")
        table.insert(output, "3. UI elements that can be manipulated")
        table.insert(output, "4. Animation/sound triggers")
        
    elseif script:IsA("ModuleScript") then
        table.insert(output, "ğŸ¯ MODULE SCRIPT - POTENTIAL VULNERABILITIES:")
        table.insert(output, "1. Global state that can be corrupted")
        table.insert(output, "2. Function tables that can be hooked")
        table.insert(output, "3. Configuration values that can be changed")
    end
    
    return table.concat(output, "\n")
end

-- Batch decompile all important scripts
function GameDecompiler:batchDecompile()
    local allOutput = {}
    local targets = self:findTargetScripts()
    
    table.insert(allOutput, "=== MURDER MYSTERY 2-STYLE GAME DECOMPILATION ===")
    table.insert(allOutput, "Found " .. #targets .. " target scripts")
    table.insert(allOutput, "Time: " .. os.date("%H:%M:%S"))
    table.insert(allOutput, "")
    
    for i, target in pairs(targets) do
        table.insert(allOutput, string.rep("=", 60))
        table.insert(allOutput, "[" .. i .. "] " .. target.name)
        table.insert(allOutput, "Path: " .. target.script:GetFullName())
        table.insert(allOutput, "Type: " .. target.type .. " | Priority: " .. target.priority)
        table.insert(allOutput, string.rep("-", 60))
        
        local decompiled = self:smartDecompile(target.script)
        table.insert(allOutput, decompiled)
        
        -- Limit to top 5 scripts to avoid huge output
        if i >= 5 then
            table.insert(allOutput, "")
            table.insert(allOutput, "âš ï¸  Limited to first 5 scripts (most important)")
            break
        end
    end
    
    table.insert(allOutput, string.rep("=", 60))
    table.insert(allOutput, "DECOMPILATION COMPLETE")
    
    return table.concat(allOutput, "\n")
end

-- Save to file with automatic naming
function GameDecompiler:saveToFile(content)
    local fileName = "game_decompile_" .. os.time() .. ".txt"
    
    if type(writefile) == "function" then
        local success, err = pcall(writefile, fileName, content)
        if success then
            return fileName, true
        else
            return "Error: " .. tostring(err), false
        end
    end
    
    return "writefile not available", false
end

-- ========== MAIN EXECUTION ==========
print("ğŸ® MURDER MYSTERY 2 GAME DECOMPILER")
print("Targeting weapon systems, trading, and game logic...")
print("")

local decompiler = GameDecompiler.new()

-- Run batch decompilation
print("ğŸš€ Starting batch decompilation...")
local result = decompiler:batchDecompile()

-- Save to file
print("ğŸ’¾ Saving to file...")
local fileName, success = decompiler:saveToFile(result)

if success then
    print("âœ… Saved to: " .. fileName)
    
    -- Show preview
    print("\nğŸ“„ PREVIEW (first 30 lines):")
    print(string.rep("-", 50))
    
    local lines = {}
    for line in result:gmatch("[^\r\n]+") do
        table.insert(lines, line)
        if #lines >= 30 then break end
    end
    
    print(table.concat(lines, "\n"))
    print("... (full output in file)")
    
else
    print("âŒ Failed to save: " .. fileName)
    print("\nğŸ“‹ OUTPUT (first 500 chars):")
    print(string.rep("-", 50))
    print(result:sub(1, 500))
    print("...")
end

print("\n" .. string.rep("=", 50))
print("COMPLETE! Check the saved file for detailed analysis.")
