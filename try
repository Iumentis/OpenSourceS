-- REAL BYTECODE ANALYZER - Extracts actual code patterns
local BytecodeAnalyzer = {}
BytecodeAnalyzer.__index = BytecodeAnalyzer

function BytecodeAnalyzer.new()
    local self = setmetatable({}, BytecodeAnalyzer)
    
    -- Game-specific keywords from your structure
    self.gameKeywords = {
        -- Weapons
        "Gun", "Knife", "Shoot", "Fire", "Bullet", "Ammo", "Reload",
        "Damage", "Hit", "Kill", "Murder", "Sheriff",
        
        -- Trading
        "Trade", "Offer", "Accept", "Decline", "Item", "Inventory",
        
        -- Game systems
        "Round", "Role", "Coin", "XP", "Level", "Prestige",
        "Event", "Quest", "BattlePass",
        
        -- Network
        "RemoteEvent", "RemoteFunction", "FireServer", "InvokeServer",
        "OnClientEvent", "OnServerEvent",
        
        -- Services
        "ReplicatedStorage", "Workspace", "Players", "UserInputService"
    }
    
    -- Common Roblox patterns to look for
    self.patterns = {
        eventCall = {"FireServer", "InvokeServer", "Connect", "Wait"},
        serviceGet = {"GetService", "WaitForChild", "FindFirstChild"},
        mathOps = {"Vector3.new", "CFrame.new", "math.random", "tick"},
        gameObjects = {"Instance.new", "Clone", "Destroy"}
    }
    
    return self
end

-- Actually analyze bytecode hex string
function BytecodeAnalyzer:analyzeBytecode(bytecode)
    if not bytecode or #bytecode < 10 then
        return {"-- No bytecode or too short"}
    end
    
    local output = {}
    table.insert(output, "=== BYTECODE ANALYSIS ===")
    table.insert(output, "Length: " .. #bytecode .. " bytes")
    table.insert(output, "")
    
    -- Convert hex to readable strings where possible
    local function hexToString(hex)
        local str = ""
        for i = 1, #hex, 2 do
            local byte = tonumber(hex:sub(i, i+1), 16)
            if byte and byte >= 32 and byte <= 126 then
                str = str .. string.char(byte)
            else
                str = str .. "."
            end
        end
        return str
    end
    
    -- Look for embedded strings in bytecode
    table.insert(output, "üîç EMBEDDED STRINGS (ASCII):")
    local foundStrings = {}
    
    -- Scan bytecode for ASCII sequences
    for i = 1, #bytecode - 4, 2 do
        local hexPair = bytecode:sub(i, i+1)
        local dec = tonumber(hexPair, 16)
        
        if dec and dec >= 65 and dec <= 90 then -- A-Z
            -- Try to extract a string sequence
            local potentialStr = ""
            for j = i, math.min(#bytecode, i + 40), 2 do
                local charHex = bytecode:sub(j, j+1)
                local charDec = tonumber(charHex, 16)
                if charDec and charDec >= 32 and charDec <= 126 then
                    potentialStr = potentialStr .. string.char(charDec)
                else
                    break
                end
            end
            
            if #potentialStr >= 3 and #potentialStr <= 30 then
                -- Check if it looks like a meaningful string
                if potentialStr:match("^[%a%.%_]+$") and 
                   not potentialStr:match("^%x+$") then -- Not just hex
                    table.insert(foundStrings, potentialStr)
                end
            end
        end
    end
    
    -- Remove duplicates and sort
    local uniqueStrings = {}
    for _, str in ipairs(foundStrings) do
        uniqueStrings[str] = true
    end
    
    local sortedStrings = {}
    for str in pairs(uniqueStrings) do
        table.insert(sortedStrings, str)
    end
    table.sort(sortedStrings)
    
    for _, str in ipairs(sortedStrings) do
        -- Highlight game-related strings
        local prefix = "  "
        for _, keyword in ipairs(self.gameKeywords) do
            if str:find(keyword) then
                prefix = "  üéØ "
                break
            end
        end
        table.insert(output, prefix .. str)
    end
    
    if #sortedStrings == 0 then
        table.insert(output, "  No readable strings found")
    end
    
    return output
end

-- Extract constants from closure
function BytecodeAnalyzer:extractConstants(closure)
    local output = {}
    
    local success, constants = pcall(debug.getconstants, closure)
    if not success or not constants then
        table.insert(output, "-- Failed to get constants")
        return output
    end
    
    table.insert(output, "üì¶ EXTRACTED CONSTANTS: " .. #constants)
    table.insert(output, "")
    
    -- Categorize constants
    local strings = {}
    local numbers = {}
    local booleans = {}
    local nils = 0
    
    for i, const in ipairs(constants) do
        local constType = type(const)
        
        if constType == "string" then
            -- Filter out garbage strings
            if #const > 0 and #const < 100 then
                -- Check for game relevance
                local isGameRelated = false
                for _, keyword in ipairs(self.gameKeywords) do
                    if const:find(keyword) then
                        isGameRelated = true
                        break
                    end
                end
                
                if isGameRelated then
                    table.insert(strings, "üéØ [" .. i .. "] \"" .. const .. "\"")
                elseif const:match("^[%a%_][%w%_]*$") then -- Looks like identifier
                    table.insert(strings, "  [" .. i .. "] \"" .. const .. "\"")
                end
            end
            
        elseif constType == "number" then
            -- Only show interesting numbers
            if const == 0 or const == 1 or const == 100 or const == 1000 or 
               const == -1 or const == 0.5 or const == 0.25 then
                table.insert(numbers, "  [" .. i .. "] " .. const)
            end
            
        elseif constType == "boolean" then
            table.insert(booleans, "  [" .. i .. "] " .. tostring(const))
            
        elseif const == nil then
            nils = nils + 1
        end
    end
    
    -- Add categorized output
    if #strings > 0 then
        table.insert(output, "üî§ STRINGS (" .. #strings .. "):")
        for _, str in ipairs(strings) do
            table.insert(output, str)
        end
        table.insert(output, "")
    end
    
    if #numbers > 0 then
        table.insert(output, "üî¢ NUMBERS (" .. #numbers .. "):")
        for _, num in ipairs(numbers) do
            table.insert(output, num)
        end
        table.insert(output, "")
    end
    
    if #booleans > 0 then
        table.insert(output, "üîò BOOLEANS (" .. #booleans .. "):")
        for _, bool in ipairs(booleans) do
            table.insert(output, bool)
        end
        table.insert(output, "")
    end
    
    if nils > 0 then
        table.insert(output, "‚óªÔ∏è  NILS: " .. nils)
        table.insert(output, "")
    end
    
    return output
end

-- Analyze function structure
function BytecodeAnalyzer:analyzeFunction(closure)
    local output = {}
    
    table.insert(output, "üîß FUNCTION STRUCTURE:")
    
    -- Get debug info
    local infoSuccess, info = pcall(debug.getinfo, closure)
    if infoSuccess and info then
        table.insert(output, "  Source: " .. (info.source or "?"))
        table.insert(output, "  What: " .. (info.what or "?"))
        table.insert(output, "  Line: " .. (info.currentline or "?"))
        table.insert(output, "  Params: " .. (info.numparams or "?"))
        table.insert(output, "")
    end
    
    -- Check closure type
    if iscclosure then
        table.insert(output, "  Type: " .. (iscclosure(closure) and "C Closure" or "Lua Closure"))
    end
    if islclosure then
        table.insert(output, "  Type: " .. (islclosure(closure) and "Lua Closure" or "C Closure"))
    end
    
    -- Get upvalues
    local upvalueSuccess, upvalues = pcall(function()
        local ups = {}
        for i = 1, math.huge do
            local success, name, value = pcall(debug.getupvalue, closure, i)
            if not success then break end
            if not name then break end
            table.insert(ups, {name = name, value = type(value)})
        end
        return ups
    end)
    
    if upvalueSuccess and #upvalues > 0 then
        table.insert(output, "")
        table.insert(output, "  üì• UPVALUES (" .. #upvalues .. "):")
        for i, upv in ipairs(upvalues) do
            table.insert(output, "    [" .. i .. "] " .. upv.name .. " (" .. upv.value .. ")")
        end
    end
    
    -- Get nested functions (protos)
    local protoSuccess, protos = pcall(debug.getprotos, closure)
    if protoSuccess and #protos > 0 then
        table.insert(output, "")
        table.insert(output, "  üîÑ NESTED FUNCTIONS (" .. #protos .. "):")
        for i, proto in ipairs(protos) do
            local protoInfo = debug.getinfo(proto)
            if protoInfo and protoInfo.source then
                local src = protoInfo.source:match("[^\\/]+$") or protoInfo.source
                table.insert(output, "    [" .. i .. "] " .. src)
            end
        end
    end
    
    return output
end

-- Main analysis function for a script
function BytecodeAnalyzer:analyzeScript(script)
    local output = {}
    
    table.insert(output, "=" .. string.rep("=", 50))
    table.insert(output, "SCRIPT ANALYSIS: " .. script:GetFullName())
    table.insert(output, "Type: " .. script.ClassName)
    table.insert(output, "=" .. string.rep("=", 50))
    table.insert(output, "")
    
    -- Try to get bytecode FIRST
    local bytecodeSuccess, bytecode = pcall(getscriptbytecode, script)
    if bytecodeSuccess and bytecode then
        local bytecodeAnalysis = self:analyzeBytecode(bytecode)
        for _, line in ipairs(bytecodeAnalysis) do
            table.insert(output, line)
        end
    else
        table.insert(output, "-- Could not get bytecode")
    end
    
    table.insert(output, "")
    
    -- Try to get closure
    local closureSuccess, closure = pcall(getscriptclosure, script)
    if closureSuccess and closure then
        -- Extract constants
        local constantsOutput = self:extractConstants(closure)
        for _, line in ipairs(constantsOutput) do
            table.insert(output, line)
        end
        
        table.insert(output, "")
        
        -- Analyze function structure
        local functionOutput = self:analyzeFunction(closure)
        for _, line in ipairs(functionOutput) do
            table.insert(output, line)
        end
    else
        table.insert(output, "-- Could not get closure")
    end
    
    -- For ModuleScripts, show source if available
    if script:IsA("ModuleScript") and script.Source and #script.Source > 0 then
        table.insert(output, "")
        table.insert(output, "üìÑ MODULE SOURCE PREVIEW:")
        table.insert(output, string.rep("-", 40))
        
        local lines = {}
        for line in script.Source:gmatch("[^\r\n]+") do
            table.insert(lines, line)
            if #lines >= 15 then break end
        end
        
        for i, line in ipairs(lines) do
            table.insert(output, string.format("%3d: %s", i, line))
        end
        
        if #script.Source > 15 * 80 then
            table.insert(output, "... (truncated)")
        end
    end
    
    table.insert(output, "")
    table.insert(output, "=" .. string.rep("=", 50))
    
    return table.concat(output, "\n")
end

-- Analyze specific game scripts from your structure
function BytecodeAnalyzer:analyzeGameScripts()
    local output = {}
    local analyzed = 0
    
    table.insert(output, "üéÆ MURDER MYSTERY 2 GAME ANALYSIS")
    table.insert(output, "Targeting key scripts from your game structure")
    table.insert(output, "Time: " .. os.date("%H:%M:%S"))
    table.insert(output, "")
    
    -- TARGET LIST from your game structure
    local targets = {
        -- HIGH PRIORITY: Weapon systems
        {name = "WeaponSystem", path = "ReplicatedStorage.Modules.WeaponSystem"},
        {name = "GunFired Handler", path = "ReplicatedStorage.ClientServices.WeaponService"},
        {name = "GunBeam Remote", path = "ReplicatedStorage.WeaponEvents.GunBeam"},
        
        -- MEDIUM PRIORITY: Game logic
        {name = "GameMode", path = "ReplicatedStorage.Modules.GameMode"},
        {name = "Trading", path = "ReplicatedStorage.Remotes"},
        
        -- TOOLS: Player weapons
        {name = "Knife Tool", search = function()
            local player = game.Players.LocalPlayer
            if player and player.Character then
                for _, child in pairs(player.Character:GetChildren()) do
                    if child:IsA("Tool") and child.Name == "Knife" then
                        return child
                    end
                end
            end
            return nil
        end}
    }
    
    -- Analyze each target
    for _, target in ipairs(targets) do
        local script = nil
        
        if target.path then
            -- Resolve path
            local parts = {}
            for part in target.path:gmatch("[^%.]+") do
                table.insert(parts, part)
            end
            
            local current = game
            for i, part in ipairs(parts) do
                if current:IsA("DataModel") then
                    current = current:GetService(part)
                else
                    current = current:WaitForChild(part, 1)
                end
                if not current then break end
            end
            
            if current and (current:IsA("Script") or current:IsA("LocalScript") or current:IsA("ModuleScript")) then
                script = current
            end
            
        elseif target.search then
            script = target.search()
        end
        
        if script then
            table.insert(output, "\n" .. string.rep("=", 60))
            table.insert(output, "ANALYZING: " .. target.name)
            table.insert(output, "Path: " .. script:GetFullName())
            table.insert(output, string.rep("-", 60))
            
            local analysis = self:analyzeScript(script)
            table.insert(output, analysis)
            
            analyzed = analyzed + 1
            
            -- Limit to avoid huge output
            if analyzed >= 3 then
                table.insert(output, "\n‚ö†Ô∏è  Limited to first 3 scripts")
                break
            end
        else
            table.insert(output, "\n‚ùå MISSING: " .. target.name .. " (" .. (target.path or "search") .. ")")
        end
    end
    
    if analyzed == 0 then
        table.insert(output, "\n‚ö†Ô∏è  No target scripts found!")
        table.insert(output, "Trying fallback analysis...")
        
        -- Fallback: Analyze ANY ModuleScript in ReplicatedStorage
        local rs = game:GetService("ReplicatedStorage")
        for _, item in pairs(rs:GetChildren()) do
            if item:IsA("ModuleScript") and analyzed < 2 then
                table.insert(output, "\n" .. string.rep("=", 60))
                table.insert(output, "FALLBACK: " .. item.Name)
                table.insert(output, string.rep("-", 60))
                
                local analysis = self:analyzeScript(item)
                table.insert(output, analysis)
                
                analyzed = analyzed + 1
            end
        end
    end
    
    table.insert(output, "\n" .. string.rep("=", 60))
    table.insert(output, "ANALYSIS COMPLETE")
    table.insert(output, "Scripts analyzed: " .. analyzed)
    
    return table.concat(output, "\n")
end

-- ========== MAIN EXECUTION ==========
print("üîç BYTECODE ANALYZER - EXTRACTING REAL DATA")
print("This will actually decode bytecode and extract constants")
print("")

local analyzer = BytecodeAnalyzer.new()
local result = analyzer:analyzeGameScripts()

-- Save to file
local fileName = "bytecode_analysis_" .. os.time() .. ".txt"

if type(writefile) == "function" then
    local success, err = pcall(writefile, fileName, result)
    if success then
        print("‚úÖ Saved analysis to: " .. fileName)
        
        -- Show preview
        print("\nüìÑ PREVIEW:")
        print(string.rep("-", 50))
        
        local lines = {}
        for line in result:gmatch("[^\r\n]+") do
            table.insert(lines, line)
            if #lines >= 20 then break end
        end
        
        print(table.concat(lines, "\n"))
        print("... (full analysis in file)")
        
    else
        print("‚ùå Failed to save: " .. tostring(err))
        print("\nüìã OUTPUT (first 500 chars):")
        print(string.rep("-", 50))
        print(result:sub(1, 500))
        print("...")
    end
else
    print("‚ö†Ô∏è  writefile not available")
    print("\nüìã OUTPUT:")
    print(string.rep("-", 50))
    print(result)
end

print("\n" .. string.rep("=", 50))
print("Check the file for ACTUAL bytecode/constant extraction!")
