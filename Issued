local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local localPlayer = Players.LocalPlayer

-- Main silent aim module
local MadworkSilentAim = {
    Enabled = false,
    TargetPart = "Head",
    MaxDistance = 500,
    WeaponId = 1,
    LastHitId = 37043
}

function MadworkSilentAim:getClosestEnemy()
    if not localPlayer.Character then return nil end
    local localHead = localPlayer.Character:FindFirstChild("Head")
    if not localHead then return nil end
    
    local closest = nil
    local closestDist = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.TeamColor ~= localPlayer.TeamColor then
            local char = workspace.CharacterContainer:FindFirstChild(player.Name)
            if char then
                local targetPart = char:FindFirstChild(self.TargetPart)
                if targetPart then
                    local dist = (targetPart.Position - localHead.Position).Magnitude
                    if dist < self.MaxDistance and dist < closestDist then
                        closestDist = dist
                        closest = {Player = player, Part = targetPart, Character = char}
                    end
                end
            end
        end
    end
    return closest
end

function MadworkSilentAim:createHitPacket(targetPart)
    self.LastHitId = self.LastHitId + 1
    
    local origin = localPlayer.Character.Head.Position
    local hitPos = targetPart.Position
    local direction = (hitPos - origin).Unit
    
    return {
        0, 0, -- Action type and index
        { -- Hits array
            {
                0, -- Hit index
                {
                    3, -- Damage type (NEED TO FIND CORRECT VALUE)
                    100, -- Damage (ADJUST THIS)
                    4, 7, -- Unknown values (CRITICAL TO FIND)
                    direction, -- Direction
                    targetPart, -- Hit instance
                    hitPos, -- Position
                    Vector3.new(0, 1, 0), -- Normal (usually up for head)
                    Vector3.new(2, 2, 2) -- Size
                },
                true, -- Valid
                0 -- Flags
            }
        },
        direction, -- Aim direction
        origin, -- Origin position
        self.LastHitId, -- Hit ID
        self.WeaponId -- Weapon ID
    }
end

function MadworkSilentAim:fireAtTarget(target)
    local combatEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("MadworkCombat_CombatEvent")
    local hitData = self:createHitPacket(target.Part)
    
    -- Fire with EventNumber 14
    local success, err = pcall(function()
        combatEvent:FireServer({hitData, 14})
    end)
    
    if not success then
        warn("Silent aim failed:", err)
        return false
    end
    return true
end

-- Hook into the combat system to intercept legitimate shots
function MadworkSilentAim:hookCombatSystem()
    local combatClient = ReplicatedStorage:WaitForChild("Client"):WaitForChild("Madwork"):WaitForChild("CombatClient")
    
    -- You would need to find and hook the Replicate function
    -- This requires analyzing the actual combat client script
end

-- Auto-fire mode
function MadworkSilentAim:toggleAutoAim()
    self.Enabled = not self.Enabled
    
    if self.Enabled then
        self.connection = game:GetService("RunService").Heartbeat:Connect(function()
            local target = self:getClosestEnemy()
            if target then
                self:fireAtTarget(target)
            end
        end)
    elseif self.connection then
        self.connection:Disconnect()
        self.connection = nil
    end
end

return MadworkSilentAim
