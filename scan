local GameStructureScanner = {}
GameStructureScanner.__index = GameStructureScanner

function GameStructureScanner.new()
    local self = setmetatable({}, GameStructureScanner)
    self.output = {}
    self.maxDepth = 3  -- How deep to scan
    self.maxChildren = 50  -- Max children per parent
    return self
end

-- Main scanning function
function GameStructureScanner:scanEverything()
    print("ðŸ“¡ Scanning game structure...")
    
    -- Start collecting
    table.insert(self.output, "=== GAME STRUCTURE SCAN ===")
    table.insert(self.output, "Generated: " .. os.date("%Y-%m-%d %H:%M:%S"))
    table.insert(self.output, "")
    
    -- Core services (most important for exploitation)
    self:scanService("Workspace", true)  -- Most important
    self:scanService("Players", true)
    self:scanService("ReplicatedStorage", true)
    self:scanService("ReplicatedFirst", true)
    self:scanService("Lighting", false)
    self:scanService("Teams", false)
    
    -- Network/communication
    self:scanService("NetworkClient", false)
    
    -- UI services
    self:scanService("CoreGui", true)
    self:scanService("StarterGui", false)
    self:scanService("StarterPack", false)
    self:scanService("StarterPlayer", false)
    
    -- Sound/music
    self:scanService("SoundService", false)

    return self:getOutput()
end

-- Scan a specific service
function GameStructureScanner:scanService(serviceName, detailed)
    local service = game:GetService(serviceName)
    if not service then return end
    
    table.insert(self.output, "")
    table.insert(self.output, "ðŸ“¦ " .. serviceName .. " (" .. service.ClassName .. ")")
    table.insert(self.output, string.rep("-", 40))
    
    if detailed then
        self:scanChildren(service, 1)
    else
        self:scanTopLevel(service)
    end
end

-- Scan children recursively (with limits)
function GameStructureScanner:scanChildren(parent, depth, path)
    path = path or parent.Name
    
    if depth > self.maxDepth then
        table.insert(self.output, "  " .. string.rep("  ", depth-1) .. "ðŸ“ ... (depth limit)")
        return
    end
    
    local children = parent:GetChildren()
    local count = 0
    
    for _, child in ipairs(children) do
        if count >= self.maxChildren then
            table.insert(self.output, "  " .. string.rep("  ", depth-1) .. "ðŸ“ ... (" .. (#children - count) .. " more)")
            break
        end
        
        local prefix = "  " .. string.rep("  ", depth-1)
        local icon = self:getIcon(child)
        local fullPath = path .. "." .. child.Name
        
        -- Show basic info
        table.insert(self.output, prefix .. icon .. child.Name .. " (" .. child.ClassName .. ")")
        
        -- Special handling for important types
        if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") or child:IsA("BindableEvent") then
            table.insert(self.output, prefix .. "  ðŸ”— " .. child.ClassName .. " - " .. fullPath)
        elseif child:IsA("Tool") then
            self:scanTool(child, depth + 1, fullPath)
        elseif child:IsA("Script") or child:IsA("LocalScript") or child:IsA("ModuleScript") then
            self:scanScript(child, depth + 1, fullPath)
        elseif child:IsA("Folder") or child:IsA("Model") then
            self:scanChildren(child, depth + 1, fullPath)
        end
        
        count = count + 1
    end
end

-- Scan top level only (for less important services)
function GameStructureScanner:scanTopLevel(parent)
    local children = parent:GetChildren()
    local importantChildren = {}
    
    -- Find important children
    for _, child in ipairs(children) do
        if self:isImportant(child) then
            table.insert(importantChildren, child)
        end
    end
    
    -- Show important ones
    for _, child in ipairs(importantChildren) do
        local icon = self:getIcon(child)
        table.insert(self.output, "  " .. icon .. child.Name .. " (" .. child.ClassName .. ")")
    end
    
    -- Show count
    table.insert(self.output, "  Total: " .. #children .. " children")
    if #importantChildren > 0 then
        table.insert(self.output, "  Important: " .. #importantChildren .. " shown above")
    end
end

-- Special scan for Tools (very important for exploitation)
function GameStructureScanner:scanTool(tool, depth, path)
    local prefix = "  " .. string.rep("  ", depth-1)
    
    -- Look for RemoteEvents in the tool
    local events = {}
    for _, child in ipairs(tool:GetDescendants()) do
        if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
            table.insert(events, child)
        end
    end
    
    if #events > 0 then
        table.insert(self.output, prefix .. "  âš¡ Remotes found:")
        for _, event in ipairs(events) do
            local eventPath = path .. "." .. event.Name
            table.insert(self.output, prefix .. "    ðŸ”— " .. event.ClassName .. " - " .. eventPath)
        end
    end
    
    -- Look for script dependencies
    local scripts = {}
    for _, child in ipairs(tool:GetDescendants()) do
        if child:IsA("Script") or child:IsA("LocalScript") then
            table.insert(scripts, child)
        end
    end
    
    if #scripts > 0 then
        table.insert(self.output, prefix .. "  ðŸ“œ Scripts: " .. #scripts)
    end
end

-- Special scan for Scripts
function GameStructureScanner:scanScript(script, depth, path)
    local prefix = "  " .. string.rep("  ", depth-1)
    
    -- Only show if it has interesting properties
    if script:IsA("ModuleScript") and script.Source and #script.Source > 0 then
        table.insert(self.output, prefix .. "  ðŸ“„ Has source (" .. #script.Source .. " chars)")
    end
    
    -- Check if it's disabled (common in anti-cheat)
    if script.Disabled then
        table.insert(self.output, prefix .. "  âš ï¸ DISABLED")
    end
end

-- Get appropriate icon for instance type
function GameStructureScanner:getIcon(instance)
    if instance:IsA("Folder") then return "ðŸ“ " end
    if instance:IsA("Model") then return "ðŸ—ï¸ " end
    if instance:IsA("Part") then return "â¬œ " end
    if instance:IsA("Script") or instance:IsA("LocalScript") then return "ðŸ“œ " end
    if instance:IsA("ModuleScript") then return "ðŸ“¦ " end
    if instance:IsA("RemoteEvent") then return "ðŸ”— " end
    if instance:IsA("RemoteFunction") then return "ðŸ”Œ " end
    if instance:IsA("BindableEvent") then return "ðŸ“¡ " end
    if instance:IsA("Tool") then return "ðŸ› ï¸ " end
    if instance:IsA("Sound") then return "ðŸ”Š " end
    if instance:IsA("BillboardGui") or instance:IsA("SurfaceGui") then return "ðŸ–¥ï¸ " end
    return "â€¢ "
end

-- Check if instance is important enough to show in top-level scan
function GameStructureScanner:isImportant(instance)
    local importantTypes = {
        "RemoteEvent", "RemoteFunction", "BindableEvent",
        "Tool", "Model", "Folder",
        "Script", "LocalScript", "ModuleScript"
    }
    
    for _, typeName in ipairs(importantTypes) do
        if instance:IsA(typeName) then
            return true
        end
    end
    
    -- Also important if it has children
    return #instance:GetChildren() > 0
end

-- Get the full output
function GameStructureScanner:getOutput()
    -- Add summary
    table.insert(self.output, "")
    table.insert(self.output, "=== SUMMARY ===")
    
    -- Count important items
    local counts = self:countImportantItems()
    for itemType, count in pairs(counts) do
        table.insert(self.output, itemType .. ": " .. count)
    end
    
    -- Add exploitation hints
    table.insert(self.output, "")
    table.insert(self.output, "=== EXPLOITATION HINTS ===")
    self:addExploitationHints()
    
    return table.concat(self.output, "\n")
end

-- Count important item types
function GameStructureScanner:countImportantItems()
    local counts = {
        ["RemoteEvents"] = 0,
        ["RemoteFunctions"] = 0,
        ["Tools"] = 0,
        ["Scripts"] = 0,
        ["Players"] = 0
    }
    
    -- Count players
    local players = game:GetService("Players"):GetPlayers()
    counts["Players"] = #players
    
    -- Helper function to count in a hierarchy
    local function countIn(parent)
        for _, child in ipairs(parent:GetDescendants()) do
            if child:IsA("RemoteEvent") then counts["RemoteEvents"] = counts["RemoteEvents"] + 1 end
            if child:IsA("RemoteFunction") then counts["RemoteFunctions"] = counts["RemoteFunctions"] + 1 end
            if child:IsA("Tool") then counts["Tools"] = counts["Tools"] + 1 end
            if child:IsA("Script") or child:IsA("LocalScript") then counts["Scripts"] = counts["Scripts"] + 1 end
        end
    end
    
    -- Count in important services
    countIn(game:GetService("Workspace"))
    countIn(game:GetService("ReplicatedStorage"))
    countIn(game:GetService("Players"))
    
    return counts
end

-- Add hints for exploitation
function GameStructureScanner:addExploitationHints()
    local players = game:GetService("Players"):GetPlayers()
    
    -- Check for local player character
    local localPlayer = game:GetService("Players").LocalPlayer
    if localPlayer and localPlayer.Character then
        table.insert(self.output, "âœ… Local player has character")
        
        -- Check for tools
        local tools = {}
        for _, child in ipairs(localPlayer.Character:GetChildren()) do
            if child:IsA("Tool") then
                table.insert(tools, child.Name)
            end
        end
        
        if #tools > 0 then
            table.insert(self.output, "ðŸ› ï¸  Tools equipped: " .. table.concat(tools, ", "))
        end
    else
        table.insert(self.output, "âš ï¸  Local player has no character")
    end
    
    -- Check workspace for important things
    local workspace = game:GetService("Workspace")
    local importantModels = {}
    
    for _, child in ipairs(workspace:GetChildren()) do
        if child:IsA("Model") and #child:GetChildren() > 5 then
            table.insert(importantModels, child.Name)
        end
    end
    
    if #importantModels > 0 then
        table.insert(self.output, "ðŸ—ï¸  Large models in workspace: " .. table.concat(importantModels, ", "))
    end
    
    -- Networking hints
    table.insert(self.output, "")
    table.insert(self.output, "ðŸ’¡ Tips for finding vulnerabilities:")
    table.insert(self.output, "1. Look for RemoteEvents in Tools")
    table.insert(self.output, "2. Check ReplicatedStorage for game modules")
    table.insert(self.output, "3. Monitor server-client communication")
    table.insert(self.output, "4. Look for disabled scripts (anti-cheat)")
end

-- Copy to clipboard
function GameStructureScanner:copyToClipboard()
    local output = self:scanEverything()
    
    -- Try to copy to clipboard
    if setclipboard then
        setclipboard(output)
        print("âœ… Copied game structure to clipboard!")
        print("ðŸ“‹ Output length: " .. #output .. " characters")
    elseif writefile then
        writefile("game_structure.txt", output)
        print("âœ… Saved game structure to game_structure.txt")
        print("ðŸ“„ Output length: " .. #output .. " characters")
    else
        print("âš ï¸  No clipboard or file functions available")
        print("ðŸ“ Output preview:")
        print(string.sub(output, 1, 500) .. "...")
    end
    
    return output
end

-- ========== USAGE ==========

print("ðŸŽ® Game Structure Scanner")
print("Collecting important game information...")

local scanner = GameStructureScanner.new()
local result = scanner:copyToClipboard()

-- Optional: Show preview
print("\nðŸ“Š Preview of collected data:")
print(string.rep("=", 50))

local lines = {}
for line in result:gmatch("[^\r\n]+") do
    table.insert(lines, line)
    if #lines >= 20 then
        break
    end
end

print(table.concat(lines, "\n"))
print("... (full output copied to clipboard)")
